# Лабораторная работа №4 по функциональной схемотехнике «Разработка модуля АЛУ для процессора MIPS» (unofficial name)

Выполнили: Акатьев Никита, Трушкина Вера гр. P33111

[Лабораторная работа №1](lab1/README.md)

[Лабораторная работа №2 и №3](lab2-3/README.md)

## Текст задания

1. Разработайте и опишите на Verilog HDL комбинационную схему для вычисления квадратного корня.
2. Добавьте комбинационную схему в качестве модуля арифметического-логического устройства процессора MIPS.
3. Напишите программу для выполнения на процессоре (HEX-формат), использующую инструкцию вычисления квадратного корня.
4. Выполните программу на процессоре и убедитесь, что она выдает верный результат.

## Описание процессора и тестового окружения

За основу взят MIPS CPU core, написанный на Verilog: https://github.com/MIPSfpga/schoolMIPS/tree/03_pipeline. Возможности данной версии процессора:

* Память инструкций
* Базовые операции на АЛУ: сложение, вычитание, побитовое ИЛИ, битовый сдвиг, сравнение, ветвление
* Память данных и операции для загрузки и чтения слов
* Конвейерная обработка инструкций

Тестовое окружение позволяет загрузить hex-файл в память инструкций. Имеется возможность отслеживать операции в конвейере, порядок выполнения инструкций и состояние регистров.

## Комбинационная схема квадратного корня

Реализация на Verilog: [sqrt.v](sqrt.v)

Использован [digit-by-digit алгоритм](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_(base_2)), основанный на битовых сдвигах. В реализации выше мы точно знаем количество разрядов, которые нужно обработать - благодаря этому мы смогли избавиться от циклов. Как результат, в ней нет ни одного дополнительного регистра и не используется сигнал синхронизации, что делает ее комбинационной схемой.

## Добавление схемы в качестве модуля АЛУ

Чтобы добавить свою инструкцию, нужно создать команду для выполнения пользователем процессора, добавить соответствующую инструкцию в АЛУ и связать их вместе. Инструкция добавлена в MIPS в качестве команды R-типа, т.е. взаимодействующей с регистрами.

Все изменения в коде schoolMIPS, сделанные в этом и следующих пунктах, экспортированы в [коммит b3110ddea7](https://gitlab.se.ifmo.ru/bobisonfire/computational-design/-/commit/b3110ddea7beee78e964f9aa35226f5f1e0edfb9).

### Пользовательская команда

Структура команды I-типа (Immediate) в MIPS:

```
┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃  op (6 bit)  ┃ rs (5 bit) ┃ rd (5 bit) ┃          Immediate (16 bit)            ┃
┗━━━━━━━━━━━━━━┻━━━━━━━━━━━━┻━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
```

Структура команды R-типа (Registers) в MIPS:

```
┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃  op (6 bit)  ┃ rs (5 bit) ┃ rt (5 bit) ┃ rd (5 bit) ┃ sa (5 bit) ┃ func (6 bit) ┃
┗━━━━━━━━━━━━━━┻━━━━━━━━━━━━┻━━━━━━━━━━━━┻━━━━━━━━━━━━┻━━━━━━━━━━━━┻━━━━━━━━━━━━━━┛
```

Ключевые поля:
* `op` - код операции. Чтобы использовать инструкции R-типа, должен быть равен `000000`
* `rs` - номер регистра первого аргумента
* `rt` - номер регистра второго аргумента
* `rd` - номер регистра с результатом
* `func` - код функции, выполняемой инструкцией R-типа.

Для `F_SQRT` был выбран свободный код функции `111111`. Теперь, если мы хотим посчитать квадратный корень числа в регистре `$t0 (rs=8)` и положить его в регистр `$t1 (rd=9)`, команда будет выглядеть так:

```
┏━━━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━┓
┃ 0 0 0 0 0 0 ┃ 0 1 0 0 0 ┃ 0 0 0 0 0 ┃ 0 1 0 0 1 ┃ 0 0 0 0 0 ┃ 1 1 1 1 1 1 ┃  HEX: 0100483F
┗━━━━━━━━━━━━━┻━━━━━━━━━━━┻━━━━━━━━━━━┻━━━━━━━━━━━┻━━━━━━━━━━━┻━━━━━━━━━━━━━┛
```

### Инструкция АЛУ

В данной реализации команды АЛУ кодируются трех-битовым числом. Свободным для `ALU_SQRT`, опять же, был выбран код `111`. АЛУ написано в поведенческом стиле, поэтому реализация инструкции выглядит очень просто:

* Вход `sqrt`-модуля - поле `srcA` (оно же `rs`)
* Выход `sqrt`-модуля пересылается в поле `result` (оно же `rd`), когда выбрана команда `ALU_SQRT`

### Связь АЛУ и пользовательской команды

Команда `F_SQRT` напрямую сопоставляется с `ALU_SQRT`, дополнительно проставляя два флага для АЛУ:

* `regDst` - отвечает за выбор регистра, куда положить результат команды (`rs` или `rd`). `regDst` равен 0, например, для команды `lui`, которая заносит в `rs` значение младших 16 бит команды. В нашем случае `regDst` равен 1.
* `regWrite` - помогает процессору понять, происходит ли в процессе выполнения запись в один из регистров. Нужен для реализации `read-during-write` механизма в MIPS.

## Программа для выполнения на процессоре

Простая программа, вычисляющая квадратный корень:

1. Очистить регистры `$t0` и `$t1`
2. Занести число `X` в регистр `$t0`
3. Вычислить `sqrt(X)` и положить результат в `$t1`

Так как команды занесения 32-битного immediate значения в регистр нет, вторую задачу выполнят две команды - одна для старших двух байт, другая - для младших двух. Пусть `X = 0xYYYYZZZZ`.

Код на MIPS-ассемблере:

```
        .text

start:  or      $t0, $0, $0
        or      $t1, $0, $0
        lui     $t0, 0xYYYY       ## Load Upper Immediate
        addiu   $t0, $t0, 0xZZZZ  ## Add Immediate Unsigned
        sqrt    $t1, $t0
end:    beq     $0,  -1           ## Branch On Equal (-1 gives an endless loop)

```

У данного метода есть серьезные ограничения, связанные с реализацией MIPS-процессора. Их лучше всего показать на примере: пусть `X = 0xFABFFABF`. Инструкция `lui $t0, 0xFABF` при обработке АЛУ превратится в команду `$t0 = 0xFABF << 16`. Инструкция `addiu $t0, $t0, 0xFABF` превратится в `$t0 = $t0 + 0xFFFFFABF`, т.е. immediate значение дополнится знаком до 32 бит (хотя `addiu` должна быть беззнаковой операцией!). Как результат, в `$t0` будет лежать `0xFABEFABF`, что не соответствует желаемому. Если сначала выполнить `addiu`, а затем `lui`, вторая операция стерет нижние 16 бит (операция `lui` делает так по определению). Другие способы вроде использования `or`, побитовых сдвигов, тоже не принесли результатов. Workaround нет, просто нельзя использовать числа, нижний байт которых начинается с единицы. 

Переведем инструкции в 32-битные слова:

```
                        ┏━━━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━┓
or      $t0, $0, $0     ┃ 0 0 0 0 0 0 ┃ 0 0 0 0 0 ┃ 0 0 0 0 0 ┃ 0 1 0 0 0 ┃ 0 0 0 0 0 ┃ 1 0 0 1 0 1 ┃  HEX: 00004025
                        ┣━━━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━━━┫
or      $t1, $0, $0     ┃ 0 0 0 0 0 0 ┃ 0 0 0 0 0 ┃ 0 0 0 0 0 ┃ 0 1 0 0 1 ┃ 0 0 0 0 0 ┃ 1 0 0 1 0 1 ┃  HEX: 00004825
                        ┣━━━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━┻━━━━━━━━━━━┻━━━━━━━━━━━━━┫
lui     $t0, YYYY       ┃ 0 0 1 1 1 1 ┃ 0 0 0 0 0 ┃ 0 1 0 0 0 ┃ Y Y Y Y  Y Y Y Y  Y Y Y Y  Y Y Y Y  ┃  HEX: 3D08YYYY
                        ┣━━━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
addiu   $t0, $t0, ZZZZ  ┃ 0 0 1 0 0 1 ┃ 0 1 0 0 0 ┃ 0 1 0 0 0 ┃ Z Z Z Z  Z Z Z Z  Z Z Z Z  Z Z Z Z  ┃  HEX: 2508ZZZZ
                        ┣━━━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━┫
sqrt    $t1, $t0        ┃ 0 0 0 0 0 0 ┃ 0 1 0 0 0 ┃ 0 0 0 0 0 ┃ 0 1 0 0 1 ┃ 0 0 0 0 0 ┃ 1 1 1 1 1 1 ┃  HEX: 0100483F
                        ┣━━━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━╋━━━━━━━━━━━┻━━━━━━━━━━━┻━━━━━━━━━━━━━┫
beq     $0,  -1         ┃ 0 0 0 1 0 0 ┃ 0 0 0 0 0 ┃ 0 0 0 0 0 ┃ 1 1 1 1  1 1 1 1  1 1 1 1  1 1 1 1  ┃  HEX: 1000FFFF
                        ┗━━━━━━━━━━━━━┻━━━━━━━━━━━┻━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
```

## Тестовое окружение

Новые тестовые сценарии можно генерировать, меняя значение YYYY и ZZZZ в hex-файле. Пример:

Пусть `X = 191 892 356 (0x0B70 0B84)`. Целочисленный корень из этого числа равен `13 852 (0x361C)`. Выставляем `regAddr = 9` (`$t1`, в который кладется результат) и убеждаемся в успехе.

[hex-файл](program.hex) с данными из примера.

Вывод тестового окружения:

```
...irrelevant...
    3  pc_F = 00000000  instr_D = 00000000   v0 = 0   nop                   nop                   nop                   nop
    4  pc_F = 00000000  instr_D = 00004025   v0 = 0   or    $8, $0, $0      nop                   nop                   nop
    5  pc_F = 00000000  instr_D = 00004825   v0 = 0   or    $9, $0, $0      or    $8, $0, $0      nop                   nop
    6  pc_F = 00000000  instr_D = 3d080b70   v0 = 0   lui   $8, 2928        or    $9, $0, $0      or    $8, $0, $0      nop
    7  pc_F = 00000000  instr_D = 25080b84   v0 = 0   addiu $8, $8, 2948    lui   $8, 2928        or    $9, $0, $0      or    $8, $0, $0
    8  pc_F = 00000000  instr_D = 0100483f   v0 = 0   sqrt  $9, $8          addiu $8, $8, 2948    lui   $8, 2928        or    $9, $0, $0
    9  pc_F = 00000000  instr_D = 1000ffff   v0 = 0   beq   $0, $0, 0       sqrt  $9, $8          addiu $8, $8, 2948    lui   $8, 2928
   10  pc_F = 00000000  instr_D = 00000000   v0 = 0   nop                   beq   $0, $0, 0       sqrt  $9, $8          addiu $8, $8, 2948
   11  pc_F = 0000361c  instr_D = 1000ffff   v0 = 0   beq   $0, $0, 0       nop                   beq   $0, $0, 0       sqrt  $9, $8
   12  pc_F = 0000361c  instr_D = 00000000   v0 = 0   nop                   beq   $0, $0, 0       nop                   beq   $0, $0, 0
...irrelevant...
```